{"ast":null,"code":"import path from 'node:path';\nimport fs, { promises as fsPromises } from 'node:fs';\nimport writeFileAtomic from 'write-file-atomic';\nimport sortKeys from 'sort-keys';\nimport detectIndent from 'detect-indent';\nimport isPlainObj from 'is-plain-obj';\nconst init = (function_, filePath, data, options) => {\n  if (!filePath) {\n    throw new TypeError('Expected a filepath');\n  }\n  if (data === undefined) {\n    throw new TypeError('Expected data to stringify');\n  }\n  options = {\n    indent: '\\t',\n    sortKeys: false,\n    ...options\n  };\n  if (options.sortKeys && isPlainObj(data)) {\n    data = sortKeys(data, {\n      deep: true,\n      compare: typeof options.sortKeys === 'function' ? options.sortKeys : undefined\n    });\n  }\n  return function_(filePath, data, options);\n};\nconst main = async (filePath, data, options) => {\n  let {\n    indent\n  } = options;\n  let trailingNewline = '\\n';\n  try {\n    const file = await fsPromises.readFile(filePath, 'utf8');\n    if (!file.endsWith('\\n')) {\n      trailingNewline = '';\n    }\n    if (options.detectIndent) {\n      indent = detectIndent(file).indent;\n    }\n  } catch (error) {\n    if (error.code !== 'ENOENT') {\n      throw error;\n    }\n  }\n  const json = JSON.stringify(data, options.replacer, indent);\n  return writeFileAtomic(filePath, `${json}${trailingNewline}`, {\n    mode: options.mode,\n    chown: false\n  });\n};\nconst mainSync = (filePath, data, options) => {\n  let {\n    indent\n  } = options;\n  let trailingNewline = '\\n';\n  try {\n    const file = fs.readFileSync(filePath, 'utf8');\n    if (!file.endsWith('\\n')) {\n      trailingNewline = '';\n    }\n    if (options.detectIndent) {\n      indent = detectIndent(file).indent;\n    }\n  } catch (error) {\n    if (error.code !== 'ENOENT') {\n      throw error;\n    }\n  }\n  const json = JSON.stringify(data, options.replacer, indent);\n  return writeFileAtomic.sync(filePath, `${json}${trailingNewline}`, {\n    mode: options.mode,\n    chown: false\n  });\n};\nexport async function writeJsonFile(filePath, data, options) {\n  await fsPromises.mkdir(path.dirname(filePath), {\n    recursive: true\n  });\n  await init(main, filePath, data, options);\n}\nexport function writeJsonFileSync(filePath, data, options) {\n  fs.mkdirSync(path.dirname(filePath), {\n    recursive: true\n  });\n  init(mainSync, filePath, data, options);\n}","map":{"version":3,"names":["path","fs","promises","fsPromises","writeFileAtomic","sortKeys","detectIndent","isPlainObj","init","function_","filePath","data","options","TypeError","undefined","indent","deep","compare","main","trailingNewline","file","readFile","endsWith","error","code","json","JSON","stringify","replacer","mode","chown","mainSync","readFileSync","sync","writeJsonFile","mkdir","dirname","recursive","writeJsonFileSync","mkdirSync"],"sources":["C:/Users/Pijus/Desktop/Projektinis/Mumis/react-app/node_modules/write-json-file/index.js"],"sourcesContent":["import path from 'node:path';\nimport fs, {promises as fsPromises} from 'node:fs';\nimport writeFileAtomic from 'write-file-atomic';\nimport sortKeys from 'sort-keys';\nimport detectIndent from 'detect-indent';\nimport isPlainObj from 'is-plain-obj';\n\nconst init = (function_, filePath, data, options) => {\n\tif (!filePath) {\n\t\tthrow new TypeError('Expected a filepath');\n\t}\n\n\tif (data === undefined) {\n\t\tthrow new TypeError('Expected data to stringify');\n\t}\n\n\toptions = {\n\t\tindent: '\\t',\n\t\tsortKeys: false,\n\t\t...options,\n\t};\n\n\tif (options.sortKeys && isPlainObj(data)) {\n\t\tdata = sortKeys(data, {\n\t\t\tdeep: true,\n\t\t\tcompare: typeof options.sortKeys === 'function' ? options.sortKeys : undefined,\n\t\t});\n\t}\n\n\treturn function_(filePath, data, options);\n};\n\nconst main = async (filePath, data, options) => {\n\tlet {indent} = options;\n\tlet trailingNewline = '\\n';\n\ttry {\n\t\tconst file = await fsPromises.readFile(filePath, 'utf8');\n\t\tif (!file.endsWith('\\n')) {\n\t\t\ttrailingNewline = '';\n\t\t}\n\n\t\tif (options.detectIndent) {\n\t\t\tindent = detectIndent(file).indent;\n\t\t}\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tconst json = JSON.stringify(data, options.replacer, indent);\n\n\treturn writeFileAtomic(filePath, `${json}${trailingNewline}`, {mode: options.mode, chown: false});\n};\n\nconst mainSync = (filePath, data, options) => {\n\tlet {indent} = options;\n\tlet trailingNewline = '\\n';\n\ttry {\n\t\tconst file = fs.readFileSync(filePath, 'utf8');\n\t\tif (!file.endsWith('\\n')) {\n\t\t\ttrailingNewline = '';\n\t\t}\n\n\t\tif (options.detectIndent) {\n\t\t\tindent = detectIndent(file).indent;\n\t\t}\n\t} catch (error) {\n\t\tif (error.code !== 'ENOENT') {\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\tconst json = JSON.stringify(data, options.replacer, indent);\n\n\treturn writeFileAtomic.sync(filePath, `${json}${trailingNewline}`, {mode: options.mode, chown: false});\n};\n\nexport async function writeJsonFile(filePath, data, options) {\n\tawait fsPromises.mkdir(path.dirname(filePath), {recursive: true});\n\tawait init(main, filePath, data, options);\n}\n\nexport function writeJsonFileSync(filePath, data, options) {\n\tfs.mkdirSync(path.dirname(filePath), {recursive: true});\n\tinit(mainSync, filePath, data, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}