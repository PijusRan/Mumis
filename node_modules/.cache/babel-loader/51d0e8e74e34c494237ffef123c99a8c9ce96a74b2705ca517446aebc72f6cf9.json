{"ast":null,"code":"// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n  const indents = new Map();\n\n  // Remember the size of previous line's indentation\n  let previousSize = 0;\n  let previousIndentType;\n\n  // Indents key (ident type + size of the indents/unindents)\n  let key;\n  for (const line of string.split(/\\n/g)) {\n    if (!line) {\n      // Ignore empty lines\n      continue;\n    }\n    let indent;\n    let indentType;\n    let use;\n    let weight;\n    let entry;\n    const matches = line.match(INDENT_REGEX);\n    if (matches === null) {\n      previousSize = 0;\n      previousIndentType = '';\n    } else {\n      indent = matches[0].length;\n      indentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n      // Ignore single space unless it's the only indent detected to prevent common false positives\n      if (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n        continue;\n      }\n      if (indentType !== previousIndentType) {\n        previousSize = 0;\n      }\n      previousIndentType = indentType;\n      use = 1;\n      weight = 0;\n      const indentDifference = indent - previousSize;\n      previousSize = indent;\n\n      // Previous line have same indent?\n      if (indentDifference === 0) {\n        // Not a new \"use\" of the current indent:\n        use = 0;\n        // But do add a bit to it for breaking ties:\n        weight = 1;\n        // We use the key from previous loop\n      } else {\n        const absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n        key = encodeIndentsKey(indentType, absoluteIndentDifference);\n      }\n\n      // Update the stats\n      entry = indents.get(key);\n      entry = entry === undefined ? [1, 0] : [entry[0] + use, entry[1] + weight];\n      indents.set(key, entry);\n    }\n  }\n  return indents;\n}\n\n// Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\nfunction encodeIndentsKey(indentType, indentAmount) {\n  const typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n  return typeCharacter + String(indentAmount);\n}\n\n// Extract the indent type and amount from a key of the indents Map.\nfunction decodeIndentsKey(indentsKey) {\n  const keyHasTypeSpace = indentsKey[0] === 's';\n  const type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n  const amount = Number(indentsKey.slice(1));\n  return {\n    type,\n    amount\n  };\n}\n\n// Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\nfunction getMostUsedKey(indents) {\n  let result;\n  let maxUsed = 0;\n  let maxWeight = 0;\n  for (const [key, [usedCount, weight]] of indents) {\n    if (usedCount > maxUsed || usedCount === maxUsed && weight > maxWeight) {\n      maxUsed = usedCount;\n      maxWeight = weight;\n      result = key;\n    }\n  }\n  return result;\n}\nfunction makeIndentString(type, amount) {\n  const indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n  return indentCharacter.repeat(amount);\n}\nexport default function detectIndent(string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  // Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n  // If no indents are identified, run again and include all indents for comprehensive detection\n  let indents = makeIndentsMap(string, true);\n  if (indents.size === 0) {\n    indents = makeIndentsMap(string, false);\n  }\n  const keyOfMostUsedIndent = getMostUsedKey(indents);\n  let type;\n  let amount = 0;\n  let indent = '';\n  if (keyOfMostUsedIndent !== undefined) {\n    ({\n      type,\n      amount\n    } = decodeIndentsKey(keyOfMostUsedIndent));\n    indent = makeIndentString(type, amount);\n  }\n  return {\n    amount,\n    type,\n    indent\n  };\n}","map":{"version":3,"names":["INDENT_REGEX","INDENT_TYPE_SPACE","INDENT_TYPE_TAB","makeIndentsMap","string","ignoreSingleSpaces","indents","Map","previousSize","previousIndentType","key","line","split","indent","indentType","use","weight","entry","matches","match","length","indentDifference","absoluteIndentDifference","encodeIndentsKey","get","undefined","set","indentAmount","typeCharacter","String","decodeIndentsKey","indentsKey","keyHasTypeSpace","type","amount","Number","slice","getMostUsedKey","result","maxUsed","maxWeight","usedCount","makeIndentString","indentCharacter","repeat","detectIndent","TypeError","size","keyOfMostUsedIndent"],"sources":["C:/Users/Pijus/Desktop/Projektinis/Mumis/react-app/node_modules/detect-indent/index.js"],"sourcesContent":["// Detect either spaces or tabs but not both to properly handle tabs for indentation and spaces for alignment\nconst INDENT_REGEX = /^(?:( )+|\\t+)/;\n\nconst INDENT_TYPE_SPACE = 'space';\nconst INDENT_TYPE_TAB = 'tab';\n\n/**\nMake a Map that counts how many indents/unindents have occurred for a given size and how many lines follow a given indentation.\n\nThe key is a concatenation of the indentation type (s = space and t = tab) and the size of the indents/unindents.\n\n```\nindents = {\n\tt3: [1, 0],\n\tt4: [1, 5],\n\ts5: [1, 0],\n\ts12: [1, 0],\n}\n```\n*/\nfunction makeIndentsMap(string, ignoreSingleSpaces) {\n\tconst indents = new Map();\n\n\t// Remember the size of previous line's indentation\n\tlet previousSize = 0;\n\tlet previousIndentType;\n\n\t// Indents key (ident type + size of the indents/unindents)\n\tlet key;\n\n\tfor (const line of string.split(/\\n/g)) {\n\t\tif (!line) {\n\t\t\t// Ignore empty lines\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet indent;\n\t\tlet indentType;\n\t\tlet use;\n\t\tlet weight;\n\t\tlet entry;\n\t\tconst matches = line.match(INDENT_REGEX);\n\n\t\tif (matches === null) {\n\t\t\tpreviousSize = 0;\n\t\t\tpreviousIndentType = '';\n\t\t} else {\n\t\t\tindent = matches[0].length;\n\t\t\tindentType = matches[1] ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\t\t\t// Ignore single space unless it's the only indent detected to prevent common false positives\n\t\t\tif (ignoreSingleSpaces && indentType === INDENT_TYPE_SPACE && indent === 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (indentType !== previousIndentType) {\n\t\t\t\tpreviousSize = 0;\n\t\t\t}\n\n\t\t\tpreviousIndentType = indentType;\n\n\t\t\tuse = 1;\n\t\t\tweight = 0;\n\n\t\t\tconst indentDifference = indent - previousSize;\n\t\t\tpreviousSize = indent;\n\n\t\t\t// Previous line have same indent?\n\t\t\tif (indentDifference === 0) {\n\t\t\t\t// Not a new \"use\" of the current indent:\n\t\t\t\tuse = 0;\n\t\t\t\t// But do add a bit to it for breaking ties:\n\t\t\t\tweight = 1;\n\t\t\t\t// We use the key from previous loop\n\t\t\t} else {\n\t\t\t\tconst absoluteIndentDifference = indentDifference > 0 ? indentDifference : -indentDifference;\n\t\t\t\tkey = encodeIndentsKey(indentType, absoluteIndentDifference);\n\t\t\t}\n\n\t\t\t// Update the stats\n\t\t\tentry = indents.get(key);\n\t\t\tentry = entry === undefined ? [1, 0] : [entry[0] + use, entry[1] + weight];\n\n\t\t\tindents.set(key, entry);\n\t\t}\n\t}\n\n\treturn indents;\n}\n\n// Encode the indent type and amount as a string (e.g. 's4') for use as a compound key in the indents Map.\nfunction encodeIndentsKey(indentType, indentAmount) {\n\tconst typeCharacter = indentType === INDENT_TYPE_SPACE ? 's' : 't';\n\treturn typeCharacter + String(indentAmount);\n}\n\n// Extract the indent type and amount from a key of the indents Map.\nfunction decodeIndentsKey(indentsKey) {\n\tconst keyHasTypeSpace = indentsKey[0] === 's';\n\tconst type = keyHasTypeSpace ? INDENT_TYPE_SPACE : INDENT_TYPE_TAB;\n\n\tconst amount = Number(indentsKey.slice(1));\n\n\treturn {type, amount};\n}\n\n// Return the key (e.g. 's4') from the indents Map that represents the most common indent,\n// or return undefined if there are no indents.\nfunction getMostUsedKey(indents) {\n\tlet result;\n\tlet maxUsed = 0;\n\tlet maxWeight = 0;\n\n\tfor (const [key, [usedCount, weight]] of indents) {\n\t\tif (usedCount > maxUsed || (usedCount === maxUsed && weight > maxWeight)) {\n\t\t\tmaxUsed = usedCount;\n\t\t\tmaxWeight = weight;\n\t\t\tresult = key;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction makeIndentString(type, amount) {\n\tconst indentCharacter = type === INDENT_TYPE_SPACE ? ' ' : '\\t';\n\treturn indentCharacter.repeat(amount);\n}\n\nexport default function detectIndent(string) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Identify indents while skipping single space indents to avoid common edge cases (e.g. code comments)\n\t// If no indents are identified, run again and include all indents for comprehensive detection\n\tlet indents = makeIndentsMap(string, true);\n\tif (indents.size === 0) {\n\t\tindents = makeIndentsMap(string, false);\n\t}\n\n\tconst keyOfMostUsedIndent = getMostUsedKey(indents);\n\n\tlet type;\n\tlet amount = 0;\n\tlet indent = '';\n\n\tif (keyOfMostUsedIndent !== undefined) {\n\t\t({type, amount} = decodeIndentsKey(keyOfMostUsedIndent));\n\t\tindent = makeIndentString(type, amount);\n\t}\n\n\treturn {\n\t\tamount,\n\t\ttype,\n\t\tindent,\n\t};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}